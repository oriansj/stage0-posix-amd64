### Copyright (C) 2020 Jeremiah Orians
### This file is part of stage0.
###
### stage0 is free software: you can redistribute it and/or modify
### it under the terms of the GNU General Public License as published by
### the Free Software Foundation, either version 3 of the License, or
### (at your option) any later version.
###
### stage0 is distributed in the hope that it will be useful,
### but WITHOUT ANY WARRANTY; without even the implied warranty of
### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
### GNU General Public License for more details.
###
### You should have received a copy of the GNU General Public License
### along with stage0.  If not, see <http://www.gnu.org/licenses/>.

# Register usage
# * R12 status
# * R13 script
# * R14 MALLOC
# * R15 command_done

### elf64.hex2: 64 bit elf header in hex2
### if you wish to use this header, you need to add :ELF_end to the end of your
### M1 or hex2 files.

## ELF Header

# :ELF_base ; (0x600000)
	7F 45 4C 46             ## e_ident[EI_MAG0-3] ELF's magic number

	02                      ## e_ident[EI_CLASS] Indicating 64 bit
	01                      ## e_ident[EI_DATA] Indicating little endianness
	01                      ## e_ident[EI_VERSION] Indicating original elf

	03                      ## e_ident[EI_OSABI] Set at 3 because FreeBSD is strict
	00                      ## e_ident[EI_ABIVERSION] Set at 0 because none cares

	00 00 00 00 00 00 00    ## e_ident[EI_PAD]
	02 00                   ## e_type Indicating Executable
	3E 00                   ## e_machine Indicating AMD64
	01 00 00 00             ## e_version Indicating original elf

	78006000 00000000       ## e_entry Address of the entry point (Number of bytes this header is + Base Address)
	40000000 00000000       ## e_phoff Address of program header table
	00 00 00 00 00 00 00 00 ## e_shoff Address of section header table

	00 00 00 00             ## e_flags
	40 00                   ## e_ehsize Indicating our 64 Byte header

	38 00                   ## e_phentsize size of a program header table
	01 00                   ## e_phnum number of entries in program table

	00 00                   ## e_shentsize size of a section header table
	00 00                   ## e_shnum number of entries in section table

	00 00                   ## e_shstrndx index of the section names

## Program Header
# :ELF_program_headers ; (0x600040)
	01 00 00 00             ## p_type
	07 00 00 00             ## ph_flags: PF-X|PF-W|PF-R = 7
	00 00 00 00 00 00 00 00 ## p_offset

	00006000 00000000       ## p_vaddr
	00006000 00000000       ## p_physaddr

	6A020000 00000000       ## p_filesz
	6A020000 00000000       ## p_memsz

	01 00 00 00 00 00 00 00 ## Required alignment

# :ELF_text
# :_start ; (0x0600078)
	58                              # POP_RAX                             ; Get the number of arguments
	5F                              # POP_RDI                             ; Get the program name
	5F                              # POP_RDI                             ; Get the actual input name
	85FF                            # TEST_EDI_EDI                        ; Check for missing output
	75 06                           # JNE8 !_start_out                    ; Have real input
	50                              # PUSH_RAX                            ; Need to adjust stack
	BF 48026000                     # LOADI32_EDI &default_file           ; Use "kaem.amd64"

# :_start_out ; (0x600085)
	31F6                            # XOR_ESI_ESI                         ; prepare read_only
	6A 02                           # PUSH !2
	58                              # POP_RAX                             ; the syscall number for open()
	0F05                            # SYSCALL                             ; Now open that damn file

	85C0                            # TEST_EAX_EAX                        ; IF NULL We couldn't open the file
	7E 66                           # JLE8 %Exit_Failure                  ; Abort hard
	4989C5                          # COPY_RAX_to_R13                     ; Set input pointer

	58                              # POP_RAX                             ; Get start of envp
	4889E5                          # COPY_RSP_to_RBP                     ; Protect envp

	6A 0C                           # PUSH !12
	58                              # POP_RAX                             ; the Syscall # for SYS_BRK
	31FF                            # XOR_EDI_EDI                         ; Get current brk
	0F05                            # SYSCALL                             ; Let the kernel do the work
	4989C6                          # COPY_RAX_to_R14                     ; Set our malloc pointer

	;; Where the main work gets done
	;; Using RDI for tokens and RSI for tokens[i]
# :main_loop ; (0x6000A1)
	31C0                            # XOR_EAX_EAX                         ; Zero RAX
	B4 08                           # LOADI8_AH !0x8                      ; Using 256 char* of space (0x800)
	E8 33010000                     # CALLI32 %malloc                     ; get it
	4889C7                          # COPY_RAX_to_RDI                     ; set tokens

	4889FE                          # COPY_RDI_to_RSI                     ; I = 0
	31C0                            # XOR_EAX_EAX                         ; Using 0
	4D31FF                          # XOR_R15_R15                         ; command_done = 0

	;; Using RAX for result and RDI for tokens[i]
# :collect_command ; (0x6000B5)
	E8 95000000                     # CALLI32 %collect_token              ; Get another token
	85C0                            # TEST_EAX_EAX                        ; if NULL == result
	74 07                           # JE8 !collect_command_comment        ; It is a comment, don't store

	488906                          # STORE64_RAX_into_Address_RSI        ; tokens[i] = result
	4883C6 08                       # ADDI8_RSI !8                        ; i = i + 1 (adjusted for char* size)

# :collect_command_comment ; (0x6000C5)
	4D85FF                          # TEST_R15_R15                        ; IF 0 == command_done
	74 EB                           # JE8 !collect_command                ; keep looping

	;; Deal with line comments
	4839FE                          # CMP_RDI_to_RSI                      ; if 0 < i
	74 D2                           # JE8 !main_loop                      ; It was a comment

	E8 4D000000                     # CALLI32 %print_command              ; print the command
	488B07                          # LOAD64_into_RAX_from_Address_RDI    ; program = tokens[0]
	85C0                            # TEST_EAX_EAX                        ; IF NULL == program
	74 1B                           # JE8 !Exit_Failure                   ; Some shit went down, abort

	57                              # PUSH_RDI                            ; Protect Tokens
	6A 39                           # PUSH !57
	58                              # POP_RAX                             ; FORKing
	0F05                            # SYSCALL                             ; int f = FORK()
	5F                              # POP_RDI                             ; Restore Tokens

	85C0                            # TEST_EAX_EAX                        ; Check fork
	7C 10                           # JL8 !Exit_Failure                   ; IF f == -1 abort hard
	75 13                           # JNE8 !collect_command_parent        ; IF f == 0 it is child

	;; Deal with child case
	6A 3B                           # PUSH !59
	58                              # POP_RAX                             ; EXECVE
	4889EA                          # COPY_RBP_to_RDX                     ; third arg = envp
	4889FE                          # COPY_RDI_to_RSI                     ; second arg = tokens
	488B3F                          # LOAD64_into_RDI_from_Address_RDI    ; program = tokens[0]
	0F05                            # SYSCALL                             ; execve(program, tokens, envp);

;; Exit_Failure function
;; Receives nothing
;; And aborts hard
;; DOES NOT RETURN
# :Exit_Failure ; (0x6000F6)
	6A 01                           # PUSH !1
	5F                              # POP_RDI                             ; All is wrong
	EB 21                           # JMP8 !Exit                          ; Exit

# :collect_command_parent ; (0x6000FB)
	4889C7                          # COPY_RAX_to_RDI                     ; first arg = f
	50                              # PUSH_RAX                            ; allocate stack for status
	4889E6                          # COPY_RSP_to_RSI                     ; second arg = &status
	31D2                            # XOR_EDX_EDX                         ; third arg = NULL
	6A 3D                           # PUSH !61
	58                              # POP_RAX                             ; WAITPID
	0F05                            # SYSCALL                             ; wait4pid(f, &status, 0, 0); [r10 = 0]

	58                              # POP_RAX                             ; Using status
	85C0                            # TEST_EAX_EAX                        ; IF 0 == status
	74 93                           # JE8 !main_loop                      ; Loop forever

	;; Deal with very unhappy case
	B8 58026000                     # LOADI32_EAX &hard                   ; Using "Subprocess error\n"
	E8 F9000000                     # CALLI32 %File_Print                 ; Print it
	EB DC                           # JMP8 !Exit_Failure                  ; return error


# :Done ; (0x60011A)
	; program completed Successfully
	31FF                            # XOR_EDI_EDI                         ; All is well
# :Exit ; (0x60011C)
	6A 3C                           # PUSH !60
	58                              # POP_RAX                             ; put the exit syscall number in rax
	0F05                            # SYSCALL                             ; Call it a good day

;; print_command function
;; Receives tokens[j] in RDI and tokens[i] in RSI
;; Modifies RAX
# :print_command ; (0x600121)
	57                              # PUSH_RDI                            ; Protect RDI
	B8 53026000                     # LOADI32_EAX &prefix                 ; using " +> "
	E8 E5000000                     # CALLI32 %File_Print                 ; print it
# :print_command_loop ; (0x60012C)
	488B07                          # LOAD64_into_RAX_from_Address_RDI    ; using tokens[j]
	E8 DD000000                     # CALLI32 %File_Print                 ; print it
	4883C7 08                       # ADDI8_to_RDI !8                     ; j = j + 1
	6A 20                           # PUSH !32
	58                              # POP_RAX                             ; using ' '
	E8 F0000000                     # CALLI32 %fputc                      ; print it
	4839FE                          # CMP_RDI_to_RSI                      ; IF j < i
	75 E7                           # JNE8 !print_command_loop            ; otherwise keep looping

	6A 0A                           # PUSH !10
	58                              # POP_RAX                             ; using '\n'
	E8 E3000000                     # CALLI32 %fputc                      ; print it
	5F                              # POP_RDI                             ; Restore RDI
	C3                              # RETURN


;; collect_token function
;; Receives nothing
;; Overwrites RAX
;; Uses RAX as C, RDI as token and RSI as token[i]
# :collect_token ; (0x60014F)
	57                              # PUSH_RDI                            ; Protect RDI
	56                              # PUSH_RSI                            ; Protect RSI
	31C0                            # XOR_EAX_EAX                         ; Zero RAX
	B4 10                           # LOADI8_AH !0x10                     ; max_string = 4096 * sizeof(char)
	E8 83000000                     # CALLI32 %malloc                     ; allocate space
	4889C7                          # COPY_RAX_to_RDI                     ; token = malloc(max_string);
	4889C6                          # COPY_RAX_to_RSI                     ; i = 0; set token[i]

# :collect_token_loop ; (0x600160)
	E8 90000000                     # CALLI32 %fgetc                      ; c = fgetc(input);
	3C FC                           # CMPI8_AL !-4                        ; if C == EOF
	74 B1                           # JE8 !Done                           ; We are done

	3C 20                           # CMPI8_AL !32                        ; IF C == ' '
	74 37                           # JE8 !collect_token_done             ; Space terminates token

	3C 09                           # CMPI8_AL !9                         ; IF C == '\t'
	74 33                           # JE8 !collect_token_done             ; tab terminates token

	3C 0A                           # CMPI8_AL !10                        ; IF C == '\n'
	75 02                           # JNE8 !collect_token_string          ; otherwise check next

	;; It is a newline
	EB 14                           # JMP8 !collect_token_set_command_done ; Set command_done = TRUE

# :collect_token_string ; (0x600177)
	3C 22                           # CMPI8_AL !34                        ; IF C == '\"'
	75 07                           # JNE8 !collect_token_comment         ; otherwise check next

	;; It is a RAW STRING
	E8 31000000                     # CALLI32 %collect_string             ; Get the rest of the string
	EB 22                           # JMP8 !collect_token_done            ; Be done

# :collect_token_comment ; (0x600182)
	3C 23                           # CMPI8_AL !35                        ; IF C == '#'
	75 0B                           # JNE8 !collect_token_escape          ; otherwise check next

	;; It is a line comment
	E8 40000000                     # CALLI32 %collect_comment            ; Read it all
# : collect_token_set_command_done ; (0x60018B)
	6A 01                           # PUSH !1
	415F                            # POP_R15                             ; Set command_done = TRUE
	EB 13                           # JMP8 !collect_token_done            ; Be done

# :collect_token_escape ; (0x600191)
	3C 5C                           # CMPI8_AL !92                        ; IF C == '\\'
	75 07                           # JNE8 !collect_token_other           ; otherwise just store it

	;; It is an escape char
	E8 5B000000                     # CALLI32 %fgetc                      ; Read the char to drop
	EB 08                           # JMP8 !collect_token_done            ; Be done

# :collect_token_other ; (0x60019C)
	8806                            # STORE8_AL_into_Address_RSI          ; token[i] = C
	4883C6 01                       # ADDI8_RSI !1                        ; i = i + 1
	EB BC                           # JMP8 !collect_token_loop            ; Keep going

# :collect_token_done ; (0x6001A4)
	4839FE                          # CMP_RDI_to_RSI                      ; IF i == 0
	75 02                           # JNE8 !collect_token_good            ; otherwise return the token
	31FF                            # XOR_EDI_EDI                         ; token = NULL

# :collect_token_good ; (0x6001AB)
	4889F8                          # COPY_RDI_to_RAX                     ; Return token
	5E                              # POP_RSI                             ; Restore RSI
	5F                              # POP_RDI                             ; Restore RDI
	C3                              # RETURN


;; collect_string function
;; Receives target[index] in RSI
;; Modifies RAX
;; Uses RAX as C
# :collect_string ; (0x6001B1)
	E8 3F000000                     # CALLI32 %fgetc                      ; C = fgetc(input)
	3C FC                           # CMPI8_AL !-4                        ; if C == EOF
	0F84 38FFFFFF                   # JE32 %Exit_Failure                  ; Something went horribly wrong

	3C 22                           # CMPI8_AL !34                        ; IF C == '\"'
	74 08                           # JE8 !collect_string_done            ; be done

	;; deal with inside of string
	8806                            # STORE8_AL_into_Address_RSI          ; target[index] = C
	4883C6 01                       # ADDI8_RSI !1                        ; index = index + 1
	EB E7                           # JMP8 !collect_string                ; Keep going

# :collect_string_done ; (0x6001CA)
	C3                              # RETURN


;; collect_comment function
;; Receives nothing
;; Modifies RAX
;; uses RAX as Int C
;; Just throws away everything it reads
# :collect_comment ; (0x6001CB)
	E8 25000000                     # CALLI32 %fgetc                      ; C = fgetc(input)
	3C FC                           # CMPI8_AL !-4                        ; IF C == EOF
	0F84 1EFFFFFF                   # JE32 %Exit_Failure                  ; abort hard

	3C 0A                           # CMPI8_AL !10                        ; IF C == '\n'
	75 EF                           # JNE8 !collect_comment               ; otherwise keep looping
	C3                              # RETURN


;; Malloc isn't actually required if the program being built fits in the initial memory
;; However, it doesn't take much to add it.
;; Requires [MALLOC] to be initialized and RAX to have the number of desired bytes
# :malloc ; (0x6001DD)
	57                              # PUSH_RDI                            ; Protect RDI
	56                              # PUSH_RSI                            ; Protect RSI
	52                              # PUSH_RDX                            ; Protect RDX
	4C89F7                          # COPY_R14_to_RDI                     ; Using the current pointer
	4801C7                          # ADD_RAX_to_RDI                      ; Request the number of desired bytes
	6A 0C                           # PUSH !12
	58                              # POP_RAX                             ; the Syscall # for SYS_BRK
	0F05                            # SYSCALL                             ; call the Kernel
	4C89F0                          # COPY_R14_to_RAX                     ; Return pointer
	4989FE                          # COPY_RDI_to_R14                     ; Update pointer
	5A                              # POP_RDX                             ; Restore RDX
	5E                              # POP_RSI                             ; Restore RSI
	5F                              # POP_RDI                             ; Restore RDI
	C3                              # RETURN


;; fgetc function
;; Loads FILE* from [script]
;; Returns -4 (EOF) or char in RAX
# :fgetc ; (0x6001F5)
	57                              # PUSH_RDI                            ; Protect RDI
	56                              # PUSH_RSI                            ; Protect RSI
	52                              # PUSH_RDX                            ; Protect RDX
	6A FC                           # PUSH !-4
	58                              # POP_RAX                             ; Put EOF in RAX
	50                              # PUSH_RAX                            ; Assume bad (If nothing read, value will remain EOF)
	488D3424                        # LEA_RSI                             ; Get stack address
	4C89EF                          # COPY_R13_to_RDI                     ; Where are we reading from
	31C0                            # XOR_EAX_EAX                         ; the syscall number for read
	6A 01                           # PUSH !1
	5A                              # POP_RDX                             ; set the size of chars we want
	0F05                            # SYSCALL                             ; call the Kernel
	58                              # POP_RAX                             ; Get either char or EOF
	3C FC                           # CMPI8_AL !-4                        ; Check for EOF
# :fgetc_done ; (0x60020D)
	5A                              # POP_RDX                             ; Restore RDX
	5E                              # POP_RSI                             ; Restore RSI
	5F                              # POP_RDI                             ; Restore RDI
	C3                              # RETURN


;; File_Print function
;; Receives CHAR* in RAX
;; calls fputc for every non-null char
# :File_Print ; (0x600211)
	57                              # PUSH_RDI                            ; Protect RDI
	56                              # PUSH_RSI                            ; Protect RSI
	4889C7                          # COPY_RAX_to_RDI                     ; Protect S
	85C0                            # TEST_EAX_EAX                        ; Protect against nulls
	74 13                           # JE8 !File_Print_Done                ; Simply don't try to print them
# :File_Print_Loop ; (0x60021A)
	31C0                            # XOR_EAX_EAX                         ; Zero RAX
	8A07                            # LOAD8_into_AL_from_Address_RDI      ; Read byte
	85C0                            # TEST_EAX_EAX                        ; Check for NULL
	74 0B                           # JE8 !File_Print_Done                ; Stop at NULL

	E8 09000000                     # CALLI32 %fputc                      ; write it
	4883C7 01                       # ADDI8_to_RDI !1                     ; S = S + 1
	EB ED                           # JMP8 !File_Print_Loop               ; Keep going

# :File_Print_Done ; (0x60022D)
	5E                              # POP_RSI                             ; Restore RSI
	5F                              # POP_RDI                             ; Restore RDI
	C3                              # RETURN


;; fputc function
;; receives CHAR in RAX and load FILE* from stdout
;; writes char and returns
# :fputc ; (0x600230)
	57                              # PUSH_RDI                            ; Protect RDI
	56                              # PUSH_RSI                            ; Protect RSI
	52                              # PUSH_RDX                            ; Protect RDX
	50                              # PUSH_RAX                            ; We are writing rax
	488D3424                        # LEA_RSI                             ; Get stack address
	6A 01                           # PUSH !1
	5F                              # POP_RDI                             ; Write to target file
	4889F8                          # COPY_RDI_to_RAX                     ; the syscall number for write
	4889FA                          # COPY_RDI_to_RDX                     ; set the size of chars we want
	0F05                            # SYSCALL                             ; call the Kernel
	58                              # POP_RAX                             ; Restore stack
	5A                              # POP_RDX                             ; Restore RDX
	5E                              # POP_RSI                             ; Restore RSI
	5F                              # POP_RDI                             ; Restore RDI
	C3                              # RETURN


# :default_file ; (0x600248)
	6B 61 65 6D 2E 61 6D 64 36 34 00                      ; "kaem.amd64"
# :prefix ; (0x600253)
	20 2B 3E 20 00                                        ; " +> "
# :hard ; (0x600258)
	53 75 62 70 72 6F 63 65 73 73 20 65 72 72 6F 72 0A 00 ; "Subprocess error\n"
# :ELF_end ; (0x60026A)
