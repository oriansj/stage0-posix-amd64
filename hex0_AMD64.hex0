### Copyright (C) 2016 Jeremiah Orians
### Copyright (C) 2017 Jan Nieuwenhuizen <janneke@gnu.org>
### Copyright (C) 2022 Andrius Å tikonas <andrius@stikonas.eu>
### This file is part of stage0.
###
### stage0 is free software: you can redistribute it and/or modify
### it under the terms of the GNU General Public License as published by
### the Free Software Foundation, either version 3 of the License, or
### (at your option) any later version.
###
### stage0 is distributed in the hope that it will be useful,
### but WITHOUT ANY WARRANTY; without even the implied warranty of
### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
### GNU General Public License for more details.
###
### You should have received a copy of the GNU General Public License
### along with stage0.  If not, see <http://www.gnu.org/licenses/>.

### elf64.hex2: 64 bit elf header in hex2
### if you wish to use this header, you need to add :ELF_end to the end of your
### M1 or hex2 files.

## ELF Header
#:ELF_base
7F 45 4C 46        ## e_ident[EI_MAG0-3] ELF's magic number

02                 ## e_ident[EI_CLASS] Indicating 64 bit
01                 ## e_ident[EI_DATA] Indicating little endianness
01                 ## e_ident[EI_VERSION] Indicating original elf

03                 ## e_ident[EI_OSABI] Set at 3 because FreeBSD is strict
00                 ## e_ident[EI_ABIVERSION] Set at 0 because none cares

00 00 00 00 00 00 00 ## e_ident[EI_PAD]
02 00              ## e_type Indicating Executable
3E 00              ## e_machine Indicating AMD64
01 00 00 00        ## e_version Indicating original elf

78 00 60 00 00 00 00 00 ## e_entry Address of the entry point (Number of bytes this header is + Base Address)
40 00 00 00 00 00 00 00 ## e_phoff Address of program header table
00 00 00 00 00 00 00 00 ## e_shoff Address of section header table

00 00 00 00        ## e_flags
40 00              ## e_ehsize Indicating our 64 Byte header

38 00              ## e_phentsize size of a program header table
01 00              ## e_phnum number of entries in program table

00 00              ## e_shentsize size of a section header table
00 00              ## e_shnum number of entries in section table

00 00              ## e_shstrndx index of the section names

## Program Header
#:ELF_program_headers
01 00 00 00             ## p_type
07 00 00 00             ## ph_flags: PF-X|PF-W|PF-R = 7
00 00 00 00 00 00 00 00 ## p_offset

00 00 60 00 00 00 00 00 ## p_vaddr
00 00 60 00 00 00 00 00 ## p_physaddr

4E 01 00 00 00 00 00 00 ## p_filesz
4E 01 00 00 00 00 00 00 ## p_memsz

01 00 00 00 00 00 00 00 ## Required alignment

#:ELF_text

# Where the ELF Header is going to hit
# Simply jump to _start
# Our main function
#:_start
	58                  ; POP_RAX         # Get the number of arguments
	5F                  ; POP_RDI         # Get the program name
	5F                  ; POP_RDI         # Get the actual input name
	31F6                ; XOR_ESI_ESI     # prepare read_only, rsi = 0
	6A02                ; PUSH_2          # prepare syscall number
	58                  ; POP_RAX         # the syscall number for open()
	0F05                ; SYSCALL         # Now open that damn file
	4989C1              ; COPY_RAX_to_R9  # Preserve the file pointer we were given

	5F                  ; POP_RDI         # Get the actual output name
	BE 41020000         ; LOADI32_ESI %577 # Prepare file as O_WRONLY|O_CREAT|O_TRUNC
	BA C0010000         ; LOADI32_EDX %448 # Prepare file as RWX for owner only (700 in octal)
	6A02                ; PUSH_2          # prepare syscall number
	58                  ; POP_RAX         # the syscall number for open()
	0F05                ; SYSCALL         # Now open that damn file
	4989C2              ; COPY_RAX_to_R10 # Preserve the file pointer we were given

	# Our flag for byte processing
	6AFF                ; PUSH_-1
	415F                ; POP_R15         # r15 = -1

	# temp storage for the sum
	4531F6              ; XOR_R14D_R14D   # r14 = 0

#:loop
	# Read a byte
	E8 95000000         ; CALLI32 %read_byte

	# process byte
	E8 24000000         ; CALLI32 %hex

	# deal with -1 values
	4885C0              ; TEST_RAX_RAX
	7C F1               ; JL8 !loop

	# deal with toggle
	4D85FF              ; TEST_R15_R15    # jump if r15 >= 0
	7D 08               ; JGE8 !print

	# process first byte of pair
	4989C6              ; MOVE_R14_RAX
	4531FF              ; XOR_R15D_R15D   # r15 = 0
	EB E4               ; JMP8 !loop

# process second byte of pair
#:print
	# update the sum and store in output
	49C1E6 04           ; SHL_R14_Immediate8 !4
	4C01F0              ; ADD_RAX_R14

	# flip the toggle
	6AFF                ; PUSH_-1
	415F                ; POP_R15         # r15 = -1

	E8 5D000000         ; CALLI32 %write_byte

	EB D2               ; JMP8 !loop

#:hex
	# Purge Comment Lines (#)
	4883F8 23           ; CMP_RAX_Immediate8 !35
	74 2C               ; JE8 !purge_comment

	# Purge Comment Lines (;)
	4883F8 3B           ; CMP_RAX_Immediate8 !59
	74 26               ; JE8 !purge_comment

	# deal all ascii less than '0'
	4883F8 30           ; CMP_RAX_Immediate8 !48
	7C 3E               ; JL8 !ascii_other

	# deal with 0-9
	4883F8 3A           ; CMP_RAX_Immediate8 !58
	7C 29               ; JL8 !ascii_num

	# deal with all ascii less than 'A'
	4883F8 41           ; CMP_RAX_Immediate8 !65
	7C 32               ; JL8 !ascii_other

	# deal with 'A'-'F'
	4883F8 47           ; CMP_RAX_Immediate8 !71
	7C 27               ; JL8 !ascii_high

	# deal with all ascii less than 'a'
	4883F8 61           ; CMP_RAX_Immediate8 !97
	7C 26               ; JL8 !ascii_other

	#deal with 'a'-'f'
	4883F8 67           ; CMP_RAX_Immediate8 !103
	7C 16               ; JL8 !ascii_low

	# The rest that remains needs to be ignored
	EB 1E               ; JMP8 !ascii_other

#:purge_comment
	# Read a byte
	E8 35000000         ; CALLI32 %read_byte

	# Loop if not LF
	4883F8 0A           ; CMP_RAX_Immediate8 !10
	75 F5               ; JNE8 !purge_comment

	# Otherwise return -1
	6AFF                ; PUSH_-1
	58                  ; POP_RAX         # rax = -1
	C3                  ; RET

#:ascii_num
	4883E8 30           ; SUB_RAX_Immediate8 !48
	C3                  ; RET

#:ascii_low
	4883E8 57           ; SUB_RAX_Immediate8 !87
	C3                  ; RET

#:ascii_high
	4883E8 37           ; SUB_RAX_Immediate8 !55
	C3                  ; RET

#:ascii_other
	6AFF                ; PUSH_-1
	58                  ; POP_RAX         # rax = -1
	C3                  ; RET

#:Done
	# program completed Successfully
	31FF                ; XOR_EDI_EDI     # All is well, rdi = 0
	6A3C                ; PUSH_60         # sycall number for exit is 60
	58                  ; POP_RAX         # put the exit syscall number in rax
	0F05                ; SYSCALL         # Call it a good day

# Writes byte stored in al
#:write_byte
	# Print our Hex
	6A01                ; PUSH_1          # prepare to set rdx to 1
	5A                  ; POP_RDX         # set the size of chars we want
	50                  ; PUSH_RAX        # Move output to stack
	4889E6              ; COPY_RSP_to_RSI # What we are writing
	4C89D7              ; COPY_R10_to_RDI # Where are we writing to
	6A01                ; PUSH_1          # prepare syscall number for write
	58                  ; POP_RAX         # get the syscall number for write
	0F05                ; SYSCALL         # call the Kernel
	5B                  ; POP_RBX         # deallocate stack
	C3                  ; RET

#:read_byte
	# Attempt to read 1 byte from STDIN
	6A01                ; PUSH_1          # prepare to set rdx to 1
	5A                  ; POP_RDX         # set the size of chars we want
	53                  ; PUSH_RBX        # allocate stack
	4889E6              ; COPY_RSP_to_RSI # Where to put it
	4C89CF              ; COPY_R9_to_RDI  # Where are we reading from
	31C0                ; XOR_EAX_EAX     # the syscall number for read
	0F05                ; SYSCALL         # call the Kernel

	4885C0              ; TEST_RAX_RAX    # check what we got
	74 D5               ; JE8 !Done       # Got EOF call it done

	# load byte
	58                  ; POP_RAX         # load char
	C3                  ; RET

#:ELF_end
